[toc]

# 数组(List)

> 数组(Array)是一种**线性表**数据结构.它用一组**连续的内存空间**, 来存储一组具有**相同类型的数据**.

定义中有几个关键字需要特意讲解一下

1. **线性表**(Linear List).线性表就是数据排成像一条线一样的结构.每个线性表上的数据最多只有前和后两个方向.数组/链表/队列/栈都是线性表结构.

![线性表](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/线性表.webp)

相反的对立面便是**非线性表**, 如二叉树/堆/图等.非线性表中, 数据之间并不是简单的前后关系.

![非线性表](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/非线性表.jpg)

2. **连续的内存空间和相同的数据**.因为这两个限制, 数组有了==随机访问==的特性.有利有弊, 两个限制让数组在删除/插入数据的操作时要做大量的数据搬移工作.

## 低效的"插入"和"删除"
>  为保持数据连续性, 插入/删除操作会变得相对低效.
### 插入

在一个长度为n的数组中.我们需要在k位置插入一个数据.此时我们需要将k~n位置的元素全都往后移一个位置.

时间复杂度的计算:如果在数组末尾插入数据不需移动其他数据, 此时时间复杂度为O(1);如果在数组的开头插入, 那么所有的数据都需要往后移动一位, 最坏时间复杂度为O(n).因我们在每个位置插入元素的概率一致, 所以平均情况时间复杂度为(1+2+...n)/n=O(n).

如果必须保持数据的有序, 则必须按照上述方法进行插入操作.但是, 如果数组中的数据没有规律, 则可以将k位置的数据移至最后, 将新的数据填入k位置即可.

![非顺序数组插入](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/非顺序数组.webp)

### 删除

与插入相似, 如要删除k位置的数据, 为了内存连续性, 需要将后续的数据向前搬移一格, 否则内存不连续.

时间复杂度上来说, 也与插入一致, 最好的情况是O(1), 最坏的情况是O(n), 平均情况O(n).

实际上, 在某些特殊情况下, 我们并不一定非得要求数组的连续性, 可以使用标记删除法, 每次删除只进行标记哪些数据是真正需要删除的.等到没有足够多的空间时再进行真正的删除操作, 可以大大的减少数据搬移的操作.

# 链表(LinkedList)

> 缓存淘汰三大策略:先进先出策略FIFO(First In, First Out)/最少使用策略(Least Frequently Used)/最近最少使用策略LRU(Least Recently Used).

因为数组需要**连续的内存空间**, 如果我们需要申请一个100MB大小的数组, 当内存中没有连续的足够大的存储空间时, 即便内存的剩余总可用大于100MB, 任然回申请失败.

链表则相反, 它通过"指针"将一组**零散的内存块**串联起来使用, 所以如果我们申请的时100MB的链表, 则不会有任何问题.

![数组-链表-内存分布](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/数组-链表-内存分布.jpg)

链表有三种常见的结构:单链表/双向链表/循环链表

## 单链表

> 链表通过指针将一组林散的内存块串联在一起.我们把内存块成为链表的"**结点**".为了将所有的节点串起来, 每个链表的结点还需要记录链上的下一个结点的地址(**后继指针next**).

![单链表.jpg (1142×399) (raw.githubusercontent.com)](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/单链表.jpg)

两个特殊的结点:

- 头结点:第一个结点, 用来记录链表的基地址.
- 尾结点:最后一个结点, 下一个结点指向空地址null.

### 链表的查找/插入/删除

数组中的插入与删除为了内存的连续性, 需要做大量的数据搬移, 所以时间复杂度是O(n), 链表本身的数据结构就是内存不连续的, 因此没有这个烦恼.

![单链表插入](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/链表插入.jpg)

## 循环列表

==循环链表是一种特殊的单向链表==.只是将尾结点的指针指向头结点.当要处理的数据具有唤醒结构特点时, 就特别适合采用循环链表.

![循环链表](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/循环链表.jpg)

## 双向链表

单向链表只有一个方向, 而双向链表增加了一个前向指针, 指向前一个结点.

![双向链表](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/双向链表.jpg)

# 栈(Stack)

> 后进先出, 先进后出即为栈(实例:平时放盘子, 从下往上一个一个放;取得时候, 我们也是从上往下一个一个一次取, 不能从中间任意抽出)

![栈实例](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/栈实例.jpg)

从操作特性上来看, **栈是一种"操作受限"的线性表**, 只允许一端的插入和删除数据.

如果使用数组实现栈则称为**顺序栈**, 如果使用链表实现栈则称为**链式栈**.

一下为java代码实现的简易顺序栈.

```java
// 基于数组实现的顺序栈
public class ArrayStack {
    private String[] items; // 数组
    private int count;		// 栈中元素个数
    private int size;			// 栈的大小
    
    // 初始化数组, 申请一个大小为n的数组空间
    public ArrayStack(int size) {
        this.items = new String[size];
        this.size = size;
        this.count = 0;
    }
    
    // 入栈操作
    public boolean push(String item) {
        if(count == n) return false;//空间不够入栈失败
		items[count] = item;
        ++count;
        return true;
    }
    
    // 出栈操作
    public String pop() {
        if(count == 0) return null;
        --count;
        return item[count+1];
    }
}
```

入栈出栈过程中, 只需要一两个临时变量存储空间, 所以空间复杂度是O(1).注意, ==空间复杂度并非此处需要大小为n的数组即为O(n).二十指出了原本的数据存储空间外, 算法运行还需要额外的存储空间.==

时间复杂度, 不管是顺序栈还是链式栈, 入栈/出栈只涉及栈顶个别数据的操作, 所以时间复杂度都是O(1).

# 队列(Queue)

> 先进先出为队列(实例:排队买票, 先来的先买)

栈只支持两个基本操作:入栈push和出栈pop, 而队列与栈相似也只支持两个基本操作:入队enqueue(从队列尾部放入数据)出队dequeue(从队列头部取出一个元素)

![队列与栈](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/队列与栈.webp)

所以队列与栈一样, 也是一种操作受限的线性表数据结构.

## 顺序队列和链式队列

数组实现为**顺序队列**, 链表实现为**链式队列**

```java
public class ArrayQueue {
    // 数组:items, 数组大小:n
    private String[] items;
    private int n = 0;
    // head表示队头下标, tail表示队尾下标
    private int head = 0;
    private int tail = 0;
    
    // 申请一个大小为capacity大小的数组
    public ArrayQueue(int capacity) {
        items = new String[capacity];
        n = capacity;
    }
    
    // 入队
    public boolean enqueue(String item) {
        if(tail == n) return false;
        items[tail] = item;
        ++tail;
        return true;
    }
    
    // 出队
    public String dequeue() {
        if (tail == head) return null;
        ++head;
        return items[tail];
    }
}
```

相对于栈只需一个**栈顶指针**.队列需要两个指针, 一个head指针指向队头, 一个tail指针, 指向队尾.

# 排序

## 排序算法的执行效率

1. 最好情况/最坏情况/平均情况时间复杂度

   需要分析出最好/最坏时间复杂度对应的排序的原始数据是什么样的;为什么要区分三种时间复杂度?

   1. 部分排序算法需要区分, 为好对比, 都做区分;

   2. 对于需要排序的数据, 有的接近无序, 有的完全无需.有序度不同的数据, 对于排序的执行时间有影响, 需要知道算法再不同数据下的性能表现.

2. 时间复杂度的系数/常熟/低阶

3. 比较次数和交换(或移动)次数

   1. ==排序算法的内存消耗==;原地排序, 特指空间复杂度时O(1)的排序算法
   2. ==排序算法的稳定性==;指待排序的序列中存在相等的元素, 经过排序之后, 相等元素之间原有的先后顺序不变

## 冒泡(Bubble Sort)

> 冒泡只会操作相邻的两个数据.==每次冒泡操作都会对相邻的两个元素进行比较, 看是否满足大小关系要求.如果不满足就让它俩互换.一次冒泡会让至少一个元素移动到它应该在的位置, 重复n次, 就完成了n个数据的排序工作.==

![冒泡排序过程](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/冒泡排序过程.webp)

上述的冒泡排序还存在优化空间, 当某次冒泡已经没有数据交换时, 就已经达到完全有序的状态, 不用再继续执行后续的冒泡操作.

```java
// 冒泡排序, a表示数组, n表示数组大小
public void bubbleSort(int[] a,  int n) {
    if (n <= 1) return;
    
    for(int i = 0; i < n; i++) {
        // 提前退出冒泡循环的标志
		boolean flag = false;
        for(int j = 0;j < n - 1 - i; j++) {
            if(a[j] > a[j + 1]) {// 交换
                flag = true;// 表示有数据交换
                int tmp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = tmp;
            }
        }
        if (!flag) break;
    }
}
```

冒泡排序只设计响铃数据的交换操作, 空间复杂度为O(1), 是一个原地排序算法;在冒泡排序中, 只有交换才可以改变两个元素的前后顺序, 在比较时两个元素大小相等不做交换, 因此是一个稳定的排序算法.时间复杂度最好情况O(n), 最坏情况O($n^2$), 平均也是O($n^2$).

## 插入(Insertion Sort)

> 将数组分为**已排序区间**和**未排序区间**.处室已排序区间只有一个, 为数组第一个元素;==核心思想:取未排序区间中的元素, 在已排序区间中找到合适的插入位置将其插入, 并保证已排序区间数据一直有序.==直至未排序区间中元素为空, 算法结束.

```java
public void insertionSort(int[] nums) {
    if (nums.length <= 1) return;
    
    for (int i = 1;i < nums.length;i++) {
        int value = nums[i];
        int j = i - 1;
        while (j >= 0) {
            if (a[j] > value) {
                a[j + 1] = a[j];
            } else {
                break;
            }
            j--;
        }
        a[j + 1] = value;
    }
}
```

插入排序:是原地排序算法, 是稳定排序算法, 最好O(n), 最坏O($n^2$), 平均O($n^2$).

## 选择排序(Selection Sort)

> 类似插入排序, 分已排序区间和未排序区间.选择排序每次从未排序区间中找到最小的元素, 将其放到已排序区间的末尾.

空间复杂度O(1), 时间:最好/最坏/平均都是O($n^2$)

## 归并排序(Merge Sort)

> 先将数组从中间分成前后两个部分, 然后对前后两部分分别进行排序, 再将排好的两部分合并在一起

![归并排序](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/归并排序.jpg)

归并排序使用**分治**思想

```java
public void mergeSort(int[] num,  int left,  int right,  int[] tmp) {
        if (left < right) {
            int mid = (left + right) / 2;
            mergeSort(num,  left,  mid,  tmp);
            mergeSort(num,  mid + 1,  right,  tmp);
            merge(num,  left,  mid,  right,  tmp);
        }
    }

    public void merge(int[] num,  int left,  int mid,  int right,  int[] tmp) {
        int i = left;
        int j = mid + 1;
        int k = 0;
		// 循环增大, 比较数组内两区域的, 将小的先放入临时数组, 直至一个区域填完
        while (i <= mid && j <= right) {
            if (num[i] < num[j]) {
                tmp[k] = num[i];
                i++;
            } else {
                tmp[k] = num[j];
                j++;
            }
            k++;
        }

        // 将剩下的区域的剩下数组赋值进临时数组
        while (i <= mid) {
            tmp[k] = num[i];
            k++;
            i++;
        }

        while (j <= right) {
            tmp[k] = num[j];
            k++;
            j++;
        }

        k = 0;
        while (left <= right) {
            num[left++] = tmp[k++];
        }
    }
```

时间复杂度 最好/最坏/平均皆为O($nlogn$)

## 快速排序(Quick Sort)

> 如需排序数组中下标l->r之前的一组数据, 选择数组中任意一个数据作为pivot(分去点), 遍历l->r之间所有的数据, 小于pivot放至左边, 大于pivot放至右边, pivot放至之间.依次再进行左右区间的排序.

![快速排序](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/快速排序.jpg)

时间复杂度一般都是O($nlogn$), 最坏情况下为O($n^2$)

## 桶排序(Bucket Sort)

> 将要排序的数据分到几个有序的桶里, 每个桶里的数据单独进行排序, 桶内排完, 再每个桶依序取出组成.

![桶排序](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/桶排序.webp)

优点:适用于外部排序, 数据量比较大的情况, 内存有限, 无法将数据全部加载岛内存中.(在硬盘中)

缺点:对要排序的数据要求苛刻.首先, ==数据需要很容易能划分成m个桶==, 且, ==桶与桶之间有着天然的大小顺序==;其次==数据再各个桶之间的分布均匀==.如果分布不均匀则导致时间复杂度逐渐向O($nlogn$)靠近.

## 计数排序(Counting Sort)

> 桶排序的一种特殊情况.适用于数据量大, 范围小的情况.

```java
public static void main(String[] args) {
    int[] arr = {2, 4, 2, 5, 1, 5, 9, 6, 3, 2, 4, 3, 0, 3, 5, 6, 3, 2, 8, 3, 2, 2, 6};
    sort(arr);
}

public static void sort(int[] arr) {
    if (num.length <= 1) return;

    // 取出数组范围
    int min = num[0];
    int max = num[0];
    for (int i = 0; i < num.length; i++) {
        int temp = num[i];
        if (temp < min) min = temp;
        if (temp > max) max = temp;
    }

    // 根据数组范围建立范围数组
    int[] arr = new int[max - min + 1];

    // 生成各数字计数数组
    for (int i = 0; i < num.length; i++) {
        int j = num[i] - min;
        arr[j] = arr[j] + 1;
    }

    // 根据计数数组排序新数组
    int index = 0;
    for (int i = 0; i < arr.length; i++) {
        while (arr[i] > 0) {
            arr[i]--;
            num[index++] = min + i;
        }
    }
}
```

# 二分查找

![二分查找](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1632379399065二分查找.webp)

```java
public int bsearch(int[] a,  int value) {
    int low = 0;
    int high = a.length - 1;
    
    while (low <= high) {
        int mid = (low + high) / 2;
        if (a[mid] == value) {
            return mid;
        } else if (a[mid] < value) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return -1;
}
```

**二分查找的局限**

1. 二分查找依赖顺序表结构, 需要满足下标随机访问元素.
2. 针对有序数据
3. 数据量小不适合二分查找
4. 数据量大也不适合二分查找

# 跳表

> 二分查找底层依赖的是数组的随机访问的特性, 所以只能用数组来实现.如果数据存储再链表中, 我们可以对链表稍加改造, 使它也拥有类似于二分查找的算法功能. 那就是我们的跳表(Skip list).

我们通过给链表加索引的方式来加快查找的速度

![一级索引](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1632380636552一级索引跳表.webp)

==加了一层索引之后, 查找一个节点的个数减少了.查找效率提高了, 如果我们多加几级索引之后呢==

![二级索引跳表](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1632380744879二级索引跳表.webp)

![1632380850336跳表查找.webp (1142×636) (raw.githubusercontent.com)](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/1632380850336跳表查找.webp)

# 散列表(Hash Table)

## 散列思想

==散列表使用数组下标随机访问时间复杂度为O(1)得特性.通过散列函数把元素的键值映射为下标, 然后将数据存储再数组对应下标得位置.当我们按照键值查询元素时, 使用同样得散列函数, 将键值转化为数组下标, 从对应得数组下标位置取得相应得数据.==

![](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1632640518160散列表.jpg)

## 散列函数

从上述例子中可以看出散列函数是非常重要的.

散列函数可以定义成**hash(key)**, 其中key表示元素的键值, hash(key)的值表经散列函数计算得到的散列值.

散列函数设计的基本要求:

1. 散列函数计算得到的散列值是一个非负整数;
2. if key1 = key2,  then hash(key1) == hash(key2)
3. if key1 != key2,  then hash(key1) != hash(key2)

第三点, 要想找到一个不同的key对应的散列值都不一样的散列函数, 几乎不可能.**散列冲突**无法避免.且有限的数组会加大散列冲突的概率.

因此我们需要通过另外的途径来解决散列冲突的问题.

## 散列冲突

> 通常使用开放寻址发(open addressing)和链表发(chaining).

### 开放寻址法

核心思想:==如果出现了散列冲突, 重新探测一个空闲位置, 将其插入.==

**线性探测**(Linear Probing)

当我们往散列表中插入数据时, 如果某个数据经过散列函数散列之后, 存储位置已经被占用了, 我们就从当前位置开始, 依次往后查找, 看是否有空闲位置, 知道找到为止.

![开放寻址法, 黄色为空闲位, 橙色为有值位.](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1632643482664开放寻址法.jpg)

==黄色为空闲位, 橙色为有值位.==

==查找==:根据散列函数得出的下标去寻找相应的键值, 如果不对应, 就继续往下查找, 直到查至下一个空闲位置则停止.

![开放寻址法查找](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1632643680722开放寻址法查找.jpg)

==删除==:删除时不可将元素设置为空, 因为后续查找的时候查询到此处判断为空则会直接结束, 导致原有的查找算法失效., 可以==将删除的元素特殊标记为deleted.当线性探测查找的时候, 遇到标记为deleted的空间, 并不是停下, 二十继续往下探测.==

![](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1632645151546开放寻址法删除.jpg)

除开线性探测外, 还有另外两种经典的方式**二次探测(Quadratic probing)**和**双重散列(Double hashing)**

==二次探测==:与线性探测很像, 线性谈下步长为1, 下标序列就是hash(key)+0, hash(key)+1, hash(key)+2...而二次探测探测的步长变成了原来的二次方, 下标序列为hash(key)+0, hash(key)+$1^2$, hash(key)+$2^2$...

==双重散列==:意为补仅使用一个散列函数.使用一组散列函数hash1(key), hash2(key), hash3(key)...我们先用第一个散列函数, 如果计算得到的存储位置已经被占用, 在用第二个散列函数, 以此类推, 知道找到空闲的存储位置.

但不管采用哪种探测方式, 当散列表空闲位置不多时, 散列冲突概率会大大提高.为尽可能保证散列表操作效率, 一般情况下, 我们会尽可能保证散列表中有一定比例空闲位置.我们用**装载因子(load factor)**来表示空位的多少.

装在因子公式:`散列表的装载因子=填入表中的元素个数/散列表的长度`

优点:全部存在数组中，可有效的利用CPU缓存加快查询速度.及序列化.

缺点:删除数据时麻烦, 需要特殊标记已删除数据.散列冲突代价高, 导致装载因子上线不能太大, 更浪费内存空间.

### 链表法

![](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1632646152642链表法.jpg)

# 树(Tree)

![](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1632820025959树.webp)

> 如同现实生活中的树, 每个元素称为"节点";链接相邻节点之间的关系为"父子关系".

![树结构](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1632820239837树结构.webp)

**父节点**:A->B

**子节点**:B->A

**兄弟节点**:B/C/D(==同一个父节点的子节点==)

**根节点**:E(无父节点)

**叶子节点**:G/H/I/J/K/L(==无子节点==)

**高度**:节点到叶子节点的最长路径(边数)

**深度**:根节点到该节点的经历边的个数

**层数**:深度+1

## 二叉树(Binary Tree)

> 二叉树, 即每个节点最多有两个子节点(**左子节点**&**右子节点**).

![二叉树类型](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1632985164959二叉树类型.webp)

**满二叉树**:==除叶子结点外, 其他所有的节点都有左右两个字节点.例2==

**完全二叉树**:==叶子节点都在最下两层, 最后一层叶子节点皆靠左排列, 除最后一层外节点数皆达到最大.==

二叉树有两种实现方式:基于链表, 基于数组

**链式存储法**

==每个节点三个字段, 一个存储数据, 另外两个存储左右子节点指针.==大部分二叉树通过这种结构来实现.

![链式二叉树(链式存储法)](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1632986104214链式二叉树.webp)

**顺序存储法**

将根节点存储再下标$i=1$的位置, 左节点存储在下标$2*i=2$位置, 右子节点存储在$2*i+1=3$的位置.以此类推, B节点的左子节点存储在$2*i=2*2=4$的位置, 右子节点存储在$2*i+1=2*2+1=7$的位置.

![数组二叉树(顺序存储法)](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1632986473373顺序二叉树.webp)

上图为完全二叉树的存储结构, 近浪费一个下标为0的存储位置.如果使用的是一个非完全二叉树的数据, 将会浪费更多的空间, 如下图

![](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1632986761601非完全二叉树.webp)

### 二叉树的遍历

- **前序遍历**:自身->左子节点->右子节点
- **中序遍历**:左子节点->自身->右子节点
- **后序遍历**:左子节点->右子节点->自身

![二叉树遍历](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1632989606622二叉树遍历.webp)

## 二叉查找树(Binary Search Tree)

> 又称二叉搜索树, 为了实现快速查找.支持快速插入删除一个数据.
>
> **树中任意一个节点, 其左子树中每个节点的值小于这个节点的值, 右子树节点的值都大于这个节点的值.**

### 查找操作

> 如果要查找的数据比根节点的值小, 再左子树递归查找, 如果比根节点大, 再右子树递归查找.

![](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1633674025111%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C.webp)

代码实现如下.

```java
public class BinarySearchTree {
    private Node tree;
    
    public Node find(int data) {
        Node p = tree;
        while (p != null) {
            if (data < p.data) p = p.left;
            else if (data > p.data) p = p.right;
            else return p;
        }
        return null;
    }
    
    public static class Node {
        private int data;
        private Node left;
        private Node right;
        
        // construct..set...get
    }
}
```

### 插入操作

> 从根节点开始, 如果插入的数据比节点的数据大, 且节点右子树为空, 将新数据查到右子节点位置, 如果不为空, 再递归遍历右子树, 查找插入位置;小则查看左子树.

![](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1633677003906%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.webp)

```java
public void insert(int data) {
    if (tree = null) {
        tree = new Node(data);
        return;
    }
    
    Node p = tree;
    while (p != null) {
        if (data > p.data) {
            if (p.right == null) {
                p.right = new Node(data);
                return;
            }
            p = p.right;
        } else {
            if (data < p.data) {
                if (p.left == null) {
                    p.left = new Node(data);
                    return;
                }
            }
            p = p.left;
        }
    }
}
```

### 删除操作

- if 删除的节点没有子节点:父节点指向要删除的节点设置为null.

- if 删除的节点只有一个节点:父节点指向要删除的节点设置为删除节点的子节点.

- if 删除的节点有两个子节点: 找到节点右子树中最小的值删除并替换至删除的节点

  ![](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1633682327328%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.webp)
  
  代码实现

```java
public void delete(int data) {
    Node p = tree;// p指向要删除的节点, 初始化指向根节点
    Node pp = null;// pp记录的是p的父节点
    while(p != null && p.data != data) {
        pp = p;
        if (data > p.data) p = p.right;
        else p = p.left;
    }
    if (p == null) return;// 没有找到.
    
    // 要删除的节点有两个子节点
    if (p.right != null && p.left != null) {
        // 查找右子树中的最小的节点
        Node minP = p.right;
        Node minPP = p;// minP的父节点
        while (minP.left != null) {
            minPP = minP;
            minP = minP.left;
        }
        
        p.data = minP.data;// 将minP的数据替换的p中
        p = minP;// 下面就变成了删除minP了
        pp = minPP;
    }
    
    // 删除节点是叶子节点或者仅有一个子节点
    Node chlid;// p的子节点
    if (p.left != null) child = p.left;
    else if (p.right != null) child = p.right;
    else child = null;
    
    if (pp == null) tree = child;// 删的是根节点
    else if (pp.left == p) pp.left = child;
    else pp.right = child;
}
```

### 重复数据的二叉查找树

当插入数据为二叉树中已存在的数据时, 我们将要插入的数据放到这个节点的右子树*也就是说, 将此数据当作大于该节点的值来处理.*当要*查找时, 遇到值相同的节点, 我们并不停止查找操作, 而是继续在右子树中查找, 知道遇到叶子节点, 才停止.这样可以把键值等于要查找值得所有节点都找出来.*

## 红黑树(Red-Black Tree)

> 平衡二叉树:*二叉书中任意一个节点得左右子树得高度相差不能大于1.*

红黑树定义

- 节点分两类, 一类红色, 一类黑色
- 根节点是黑色
- 叶子节点都是黑色空节点(NIL), 即, 叶子节点不存储数据
- 任何相邻的节点不能同时为红色
- 每个节点, 从该节点到达其可达叶子节点的所有路径, 都包含相同数目的黑色节点

![红黑树](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1633933151834%E7%BA%A2%E9%BB%91%E6%A0%91.webp)

**左旋与右旋**

![](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1633935684589%E7%BA%A2%E9%BB%91%E6%A0%91%E5%B7%A6%E5%8F%B3%E6%97%8B.webp)

### 实现细节

> 红黑树, 在插入\删除数据之后, 平衡会被破坏, 因此我们在进行相关操作的时候, 需要对平衡进行调整

**插入操作**

- 插入的节点必须是红色的.且插入的节点都放在叶子节点上.
- if插入节点的父节点是黑色的, 不用任何操作.
- if插入根节点, 只用改变为黑色即可.

==具体实现暂时放弃研究==

# 堆(Heap)

> - 堆是一个完全二叉树(除最后一层其他层节点皆满, 最后一层靠左排列)
>
> - 堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点值
>
> 完全二叉树适合数组存储.

每个节点的值都大于等于子节点称为"==大顶堆==", 每个节点的值都小于等于子节点称为"==小顶堆==".

## 插入(自下而上堆化)

**堆化(heapify)**:堆化分为**自上而下**和**自下而上**, 此处为自下而上.==将数据插入数组末尾后, 逐个向上与父节点进行大小比较, 部门组就交换节点重复至满足大小关系为止.== 

![插入-堆化](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1634026689359%E6%8F%92%E5%85%A5-%E5%A0%86%E5%8C%96-%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A.jpg)

```java
public class Heap {
    private int[] a;// 数组,从下标1开始存储数据
    private int n;// 堆可以存储的最大数据个数
    private int count;// 队中已经存储的数据个数
    
    public Heap(int capacity) {
		a = new int[capacity + 1];
        n = capacity;
        count = 0;
    }
    
    public void insert(int data) {
        if (count >= n) throw new Exception("stack overflow"); // 堆满了
        a[++count] = data;
        int i = count;
        while (i / 2 > 0 && a[i] > a[i / 2]) {
            swap(a, i, i/2);
            i = i / 2;
        }
    }
    public void swap(int[] a, n, i) {
    	int temp = a[n];
	    a[n] = a[i];
	    a[i] = temp;
	}
}
```

## 删除(自上而下堆化)

假设构造了一个大顶堆, 当我们删除了堆顶元素之后, 需要从左右子树中选出第二大的元素放在堆顶, 依次迭代删除第二大节点, 直到叶子节点删除. 但是这样操作之后明显结构不满足完全二叉树的特性. 因此需要改变思路, 将最后一个节点防止堆顶, 在进行判断操作进行替换. 

![删除-堆化-自上而下](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1634029325391%E5%88%A0%E9%99%A4-%E5%A0%86%E5%8C%96-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B.jpg)

```java
public void removeMax() {
    if (count == 0) throw new Exception("No such data");// 堆中没有数据
    a[1] = a[count];
    --count;
    heapify(a, count, 1)
}

private void heapify(int[] a, int n, int i) { // 自上而下的堆化
    while(true) {
        int maxPos = i;
        if(i * 2 <= n && a[i] < a[i * 2]) maxPos = i * 2;
        if(i * 2 + 1 <= n && a[maxPos] < a[i * 2 + 1]) maxPos = i * 2 + 1;
        if(maxPos == i)break;
        swap(a, i, maxPos);
        i = maxPos;
    }
}
public void swap(int[] a, n, i) {
    int temp = a[n];
    a[n] = a[i];
    a[i] = temp;
}
```

##  堆排序(Heap Sort)

> 借助堆结构时限的排序算法, 称为堆排序. 此算法时间复杂度非常稳定O($n log n$), 且是原地排序算法. 堆排序大致分为两个步骤, **建堆**和**排序**. 

### 1.建堆

首先将数组原地建成一个堆, 建堆有两种堆化思路. 

- 自下而上堆化: 尽管数组中包含了n个数据, 但我们假设, 起初堆中只包含一个数据, 就是下标为1的数据. 之后, 我们调用插入操作, 将下标从2 到 n的数据依次插入至堆中.
- 自上而下堆化: 从最后一个非叶子节点(n/2)开始, 依次堆化即可. 

![](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1635129163859%E5%A0%86%E6%8E%92%E5%BA%8F-%E5%BB%BA%E5%A0%86.png)

代码实现,自上而下堆化思路

```java
public void buildHeap(int[] a, int n) {
    // 此处可能需要将数组进行扩大一位处理
    for (int i = n/2; i > 0; i--) {
        heapify(a, n, i);
    }
}
public void heapify(int[] a, int n, int i) {
    while (true) {
        int maxPos = i;
        if (i*2 < n && a[i] < a[i * 2]) maxPos = i * 2;
        if (i*2+1 < n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
        if (maxPos = i) break;
        swap(a, maxPos, i);
        i = maxPos;
    }
}
public void swap(int[] a, n, i) {
    int temp = a[n];
    a[n] = a[i];
    a[i] = temp;
}
```

### 2.排序

建堆结束后,是一个大顶堆的, 堆顶元素即是最大的元素. 我们可以将最后一个元素与之交换. 进行一个类似上述删除操作的自上而下堆化. 直至堆中只剩下最后一个数据. 

![](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1635131686910%E5%A0%86%E6%8E%92%E5%BA%8F-%E6%8E%92%E5%BA%8F.webp)

代码实现

```java
public void sort(int[] a, int n) {
    buildHeap(a, n);
    int k = n;
    while (k > 1) {
		swap(a, k, 1);
        k--;
        heapify(a, k, 1);
    }
}

public void swap(int[] a, n, i) {
    int temp = a[n];
    a[n] = a[i];
    a[i] = temp;
}
```

# 图(Graph)

> 一种非线性表数据结构, **图**比树更复杂.

图中的元素成为**顶点**(vertex). 元素之间的关系成为**边**(edge).

![图](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1636012661643%E5%9B%BE.webp)

微信和微博的社交关系可以使用图来表示, 举例微信, 每个用户看作一个顶点. 两个用户互相添加好友, 即两者之间建立一条边. 因此, 整个微信好友关系可以使用图来表示. ==**度**(degree)连顶相连接的边的条数.==

举例微博, 微博比微信更加复杂, 还存在一种单向关注的关系. 此处可以引入边的方向.

![有向图](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1636015725835%E6%9C%89%E5%90%91%E5%9B%BE.jpg)

**入度**(In-degree): 表有多少边指向这个顶点.

**出度**(Out-degree): 表多少有多少条边以次顶点为起点指向其他顶点.

而QQ中还有一种叫做亲密度的功能, 用以记录两个用户之间的亲密值. 此情况需要用到**带权图**(weighted graph), 每条边都有一个权重(weight), 可以通过权重表示QQ好友亲密值.

![带权图](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1636075856374%E5%B8%A6%E6%9D%83%E5%9B%BE.webp)

## 邻接矩阵存储方法(Adjacency Matrix)

底层依赖一个二维数组. 于无向图, 顶点i与顶点j之间有边, 则将`A[i][j]`与`A[j][i]`标记为1; 于有向图, 如果有一条i指向j的边, 则将`A[i][j]`; 于带权图, 则将数组中存的数据存储为权重. 

![邻接矩阵](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1636078328881%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.webp)

缺点: ==浪费存储空间==. (例, 无向图中当`A[i][j]`为1时, `A[j][i]`也必然为1, 其中浪费了一半的空间存储; 如存储**稀疏图**(Spare Matrix), 顶点多, 边少的图, 此方法将更加浪费空间.)

优点: ==存储方式简单,  高效; 计算方便, 可将图的运算转换为矩阵之间的运算.== 

## 邻接表存储方法(Adjacency List)

