[toc]

# 数组

> 数组(Array)是一种**线性表**数据结构.它用一组**连续的内存空间**,来存储一组具有**相同类型的数据**.

定义中有几个关键字需要特意讲解一下

1. **线性表**(Linear List).线性表就是数据排成像一条线一样的结构.每个线性表上的数据最多只有前和后两个方向.数组/链表/队列/栈都是线性表结构.

![线性表](../img/线性表.webp)

相反的对立面便是**非线性表**,如二叉树/堆/图等.非线性表中,数据之间并不是简单的前后关系.

![非线性表](../img/非线性表.jpg)

2. **连续的内存空间和相同的数据**.因为这两个限制,数组有了==随机访问==的特性.有利有弊,两个限制让数组在删除/插入数据的操作时要做大量的数据搬移工作.

## 低效的"插入"和"删除"
>  为保持数据连续性,插入/删除操作会变得相对低效.
### 插入

在一个长度为n的数组中.我们需要在k位置插入一个数据.此时我们需要将k~n位置的元素全都往后移一个位置.

时间复杂度的计算:如果在数组末尾插入数据不需移动其他数据,此时时间复杂度为O(1);如果在数组的开头插入,那么所有的数据都需要往后移动一位,最坏时间复杂度为O(n).因我们在每个位置插入元素的概率一致,所以平均情况时间复杂度为(1+2+...n)/n=O(n).

如果必须保持数据的有序,则必须按照上述方法进行插入操作.但是,如果数组中的数据没有规律,则可以将k位置的数据移至最后,将新的数据填入k位置即可.

![非顺序数组插入](../img/非顺序数组.webp)

### 删除

与插入相似,如要删除k位置的数据,为了内存连续性,需要将后续的数据向前搬移一格,否则内存不连续.

时间复杂度上来说,也与插入一致,最好的情况是O(1),最坏的情况是O(n),平均情况O(n).

实际上,在某些特殊情况下,我们并不一定非得要求数组的连续性,可以使用标记删除法,每次删除只进行标记哪些数据是真正需要删除的.等到没有足够多的空间时再进行真正的删除操作,可以大大的减少数据搬移的操作.

# 链表

> 缓存淘汰三大策略:先进先出策略FIFO(First In,First Out)/最少使用策略(Least Frequently Used)/最近最少使用策略LRU(Least Recently Used).

因为数组需要**连续的内存空间**,如果我们需要申请一个100MB大小的数组,当内存中没有连续的足够大的存储空间时,即便内存的剩余总可用大于100MB,任然回申请失败.

链表则相反,它通过"指针"将一组**零散的内存块**串联起来使用,所以如果我们申请的时100MB的链表,则不会有任何问题.

![数组-链表-内存分布](../img/数组-链表-内存分布.jpg)

链表有三种常见的结构:单链表/双向链表/循环链表

## 单链表

> 链表通过指针将一组林散的内存块串联在一起.我们把内存块成为链表的"**结点**".为了将所有的节点串起来,每个链表的结点还需要记录链上的下一个结点的地址(**后继指针next**).

![单链表](../img/单链表.jpg)

两个特殊的结点:

- 头结点:第一个结点,用来记录链表的基地址.
- 尾结点:最后一个结点,下一个结点指向空地址null.

### 链表的查找/插入/删除

数组中的插入与删除为了内存的连续性,需要做大量的数据搬移,所以时间复杂度是O(n),链表本身的数据结构就是内存不连续的,因此没有这个烦恼.

![单链表插入](../img/链表插入.jpg)

## 循环列表

==循环链表是一种特殊的单向链表==.只是将尾结点的指针指向头结点.当要处理的数据具有唤醒结构特点时,就特别适合采用循环链表.

![循环链表](../img/循环链表.jpg)

## 双向链表

单向链表只有一个方向,而双向链表增加了一个前向指针,指向前一个结点.

![双向链表](../img/双向链表.jpg)

