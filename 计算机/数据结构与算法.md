[toc]

# 数组

> 数组(Array)是一种**线性表**数据结构.它用一组**连续的内存空间**,来存储一组具有**相同类型的数据**.

定义中有几个关键字需要特意讲解一下

1. **线性表**(Linear List).线性表就是数据排成像一条线一样的结构.每个线性表上的数据最多只有前和后两个方向.数组/链表/队列/栈都是线性表结构.

![线性表](../img/线性表.webp)

相反的对立面便是**非线性表**,如二叉树/堆/图等.非线性表中,数据之间并不是简单的前后关系.

![非线性表](../img/非线性表.jpg)

2. **连续的内存空间和相同的数据**.因为这两个限制,数组有了==随机访问==的特性.有利有弊,两个限制让数组在删除/插入数据的操作时要做大量的数据搬移工作.

## 低效的"插入"和"删除"
>  为保持数据连续性,插入/删除操作会变得相对低效.
### 插入

在一个长度为n的数组中.我们需要在k位置插入一个数据.此时我们需要将k~n位置的元素全都往后移一个位置.

时间复杂度的计算:如果在数组末尾插入数据不需移动其他数据,此时时间复杂度为O(1);如果在数组的开头插入,那么所有的数据都需要往后移动一位,最坏时间复杂度为O(n).因我们在每个位置插入元素的概率一致,所以平均情况时间复杂度为(1+2+...n)/n=O(n).

如果必须保持数据的有序,则必须按照上述方法进行插入操作.但是,如果数组中的数据没有规律,则可以将k位置的数据移至最后,将新的数据填入k位置即可.

![非顺序数组插入](../img/非顺序数组.webp)

### 删除

与插入相似,如要删除k位置的数据,为了内存连续性,需要将后续的数据向前搬移一格,否则内存不连续.

时间复杂度上来说,也与插入一致,最好的情况是O(1),最坏的情况是O(n),平均情况O(n).

实际上,在某些特殊情况下,我们并不一定非得要求数组的连续性,可以使用标记删除法,每次删除只进行标记哪些数据是真正需要删除的.等到没有足够多的空间时再进行真正的删除操作,可以大大的减少数据搬移的操作.

# 链表

> 缓存淘汰三大策略:先进先出策略FIFO(First In,First Out)/最少使用策略(Least Frequently Used)/最近最少使用策略LRU(Least Recently Used).

因为数组需要**连续的内存空间**,如果我们需要申请一个100MB大小的数组,当内存中没有连续的足够大的存储空间时,即便内存的剩余总可用大于100MB,任然回申请失败.

链表则相反,它通过"指针"将一组**零散的内存块**串联起来使用,所以如果我们申请的时100MB的链表,则不会有任何问题.

![数组-链表-内存分布](../img/数组-链表-内存分布.jpg)

链表有三种常见的结构:单链表/双向链表/循环链表

## 单链表

> 链表通过指针将一组林散的内存块串联在一起.我们把内存块成为链表的"**结点**".为了将所有的节点串起来,每个链表的结点还需要记录链上的下一个结点的地址(**后继指针next**).

![单链表](../img/单链表.jpg)

两个特殊的结点:

- 头结点:第一个结点,用来记录链表的基地址.
- 尾结点:最后一个结点,下一个结点指向空地址null.

### 链表的查找/插入/删除

数组中的插入与删除为了内存的连续性,需要做大量的数据搬移,所以时间复杂度是O(n),链表本身的数据结构就是内存不连续的,因此没有这个烦恼.

![单链表插入](../img/链表插入.jpg)

## 循环列表

==循环链表是一种特殊的单向链表==.只是将尾结点的指针指向头结点.当要处理的数据具有唤醒结构特点时,就特别适合采用循环链表.

![循环链表](../img/循环链表.jpg)

## 双向链表

单向链表只有一个方向,而双向链表增加了一个前向指针,指向前一个结点.

![双向链表](../img/双向链表.jpg)

# 栈

> 后进先出,先进后出即为栈(实例:平时放盘子,从下往上一个一个放;取得时候,我们也是从上往下一个一个一次取,不能从中间任意抽出)

![栈实例](../img/栈实例.jpg)

从操作特性上来看,**栈是一种"操作受限"的线性表**,只允许一端的插入和删除数据.

如果使用数组实现栈则称为**顺序栈**,如果使用链表实现栈则称为**链式栈**.

一下为java代码实现的简易顺序栈.

```java
// 基于数组实现的顺序栈
public class ArrayStack {
    private String[] items; // 数组
    private int count;		// 栈中元素个数
    private int size;			// 栈的大小
    
    // 初始化数组,申请一个大小为n的数组空间
    public ArrayStack(int size) {
        this.items = new String[size];
        this.size = size;
        this.count = 0;
    }
    
    // 入栈操作
    public boolean push(String item) {
        if(count == n) return false;//空间不够入栈失败
		items[count] = item;
        ++count;
        return true;
    }
    
    // 出栈操作
    public String pop() {
        if(count == 0) return null;
        --count;
        return item[count+1];
    }
}
```

入栈出栈过程中,只需要一两个临时变量存储空间,所以空间复杂度是O(1).注意,==空间复杂度并非此处需要大小为n的数组即为O(n).二十指出了原本的数据存储空间外,算法运行还需要额外的存储空间.==

时间复杂度,不管是顺序栈还是链式栈,入栈/出栈只涉及栈顶个别数据的操作,所以时间复杂度都是O(1).

# 队列

> 先进先出为队列(实例:排队买票,先来的先买)

栈只支持两个基本操作:入栈push和出栈pop,而队列与栈相似也只支持两个基本操作:入队enqueue(从队列尾部放入数据)出队dequeue(从队列头部取出一个元素)

![队列与栈](../img/队列与栈.webp)

所以队列与栈一样,也是一种操作受限的线性表数据结构.

## 顺序队列和链式队列

数组实现为**顺序队列**,链表实现为**链式队列**

```java
public class ArrayQueue {
    // 数组:items,数组大小:n
    private String[] items;
    private int n = 0;
    // head表示队头下标,tail表示队尾下标
    private int head = 0;
    private int tail = 0;
    
    // 申请一个大小为capacity大小的数组
    public ArrayQueue(int capacity) {
        items = new String[capacity];
        n = capacity;
    }
    
    // 入队
    public boolean enqueue(String item) {
        if(tail == n) return false;
        items[tail] = item;
        ++tail;
        return true;
    }
    
    // 出队
    public String dequeue() {
        if (tail == head) return null;
        ++head;
        return items[tail];
    }
}
```

相对于栈只需一个**栈顶指针**.队列需要两个指针,一个head指针指向队头,一个tail指针,指向队尾.
