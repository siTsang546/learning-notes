[toc]

# 数组(List)

> 数组(Array)是一种**线性表**数据结构.它用一组**连续的内存空间**,来存储一组具有**相同类型的数据**.

定义中有几个关键字需要特意讲解一下

1. **线性表**(Linear List).线性表就是数据排成像一条线一样的结构.每个线性表上的数据最多只有前和后两个方向.数组/链表/队列/栈都是线性表结构.

![线性表](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/线性表.webp)

相反的对立面便是**非线性表**,如二叉树/堆/图等.非线性表中,数据之间并不是简单的前后关系.

![非线性表](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/非线性表.jpg)

2. **连续的内存空间和相同的数据**.因为这两个限制,数组有了==随机访问==的特性.有利有弊,两个限制让数组在删除/插入数据的操作时要做大量的数据搬移工作.

## 低效的"插入"和"删除"
>  为保持数据连续性,插入/删除操作会变得相对低效.
### 插入

在一个长度为n的数组中.我们需要在k位置插入一个数据.此时我们需要将k~n位置的元素全都往后移一个位置.

时间复杂度的计算:如果在数组末尾插入数据不需移动其他数据,此时时间复杂度为O(1);如果在数组的开头插入,那么所有的数据都需要往后移动一位,最坏时间复杂度为O(n).因我们在每个位置插入元素的概率一致,所以平均情况时间复杂度为(1+2+...n)/n=O(n).

如果必须保持数据的有序,则必须按照上述方法进行插入操作.但是,如果数组中的数据没有规律,则可以将k位置的数据移至最后,将新的数据填入k位置即可.

![非顺序数组插入](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/非顺序数组.webp)

### 删除

与插入相似,如要删除k位置的数据,为了内存连续性,需要将后续的数据向前搬移一格,否则内存不连续.

时间复杂度上来说,也与插入一致,最好的情况是O(1),最坏的情况是O(n),平均情况O(n).

实际上,在某些特殊情况下,我们并不一定非得要求数组的连续性,可以使用标记删除法,每次删除只进行标记哪些数据是真正需要删除的.等到没有足够多的空间时再进行真正的删除操作,可以大大的减少数据搬移的操作.

# 链表(LinkedList)

> 缓存淘汰三大策略:先进先出策略FIFO(First In,First Out)/最少使用策略(Least Frequently Used)/最近最少使用策略LRU(Least Recently Used).

因为数组需要**连续的内存空间**,如果我们需要申请一个100MB大小的数组,当内存中没有连续的足够大的存储空间时,即便内存的剩余总可用大于100MB,任然回申请失败.

链表则相反,它通过"指针"将一组**零散的内存块**串联起来使用,所以如果我们申请的时100MB的链表,则不会有任何问题.

![数组-链表-内存分布](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/数组-链表-内存分布.jpg)

链表有三种常见的结构:单链表/双向链表/循环链表

## 单链表

> 链表通过指针将一组林散的内存块串联在一起.我们把内存块成为链表的"**结点**".为了将所有的节点串起来,每个链表的结点还需要记录链上的下一个结点的地址(**后继指针next**).

![单链表.jpg (1142×399) (raw.githubusercontent.com)](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/单链表.jpg)

两个特殊的结点:

- 头结点:第一个结点,用来记录链表的基地址.
- 尾结点:最后一个结点,下一个结点指向空地址null.

### 链表的查找/插入/删除

数组中的插入与删除为了内存的连续性,需要做大量的数据搬移,所以时间复杂度是O(n),链表本身的数据结构就是内存不连续的,因此没有这个烦恼.

![单链表插入](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/链表插入.jpg)

## 循环列表

==循环链表是一种特殊的单向链表==.只是将尾结点的指针指向头结点.当要处理的数据具有唤醒结构特点时,就特别适合采用循环链表.

![循环链表](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/循环链表.jpg)

## 双向链表

单向链表只有一个方向,而双向链表增加了一个前向指针,指向前一个结点.

![双向链表](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/双向链表.jpg)

# 栈(Stack)

> 后进先出,先进后出即为栈(实例:平时放盘子,从下往上一个一个放;取得时候,我们也是从上往下一个一个一次取,不能从中间任意抽出)

![栈实例](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/栈实例.jpg)

从操作特性上来看,**栈是一种"操作受限"的线性表**,只允许一端的插入和删除数据.

如果使用数组实现栈则称为**顺序栈**,如果使用链表实现栈则称为**链式栈**.

一下为java代码实现的简易顺序栈.

```java
// 基于数组实现的顺序栈
public class ArrayStack {
    private String[] items; // 数组
    private int count;		// 栈中元素个数
    private int size;			// 栈的大小
    
    // 初始化数组,申请一个大小为n的数组空间
    public ArrayStack(int size) {
        this.items = new String[size];
        this.size = size;
        this.count = 0;
    }
    
    // 入栈操作
    public boolean push(String item) {
        if(count == n) return false;//空间不够入栈失败
		items[count] = item;
        ++count;
        return true;
    }
    
    // 出栈操作
    public String pop() {
        if(count == 0) return null;
        --count;
        return item[count+1];
    }
}
```

入栈出栈过程中,只需要一两个临时变量存储空间,所以空间复杂度是O(1).注意,==空间复杂度并非此处需要大小为n的数组即为O(n).二十指出了原本的数据存储空间外,算法运行还需要额外的存储空间.==

时间复杂度,不管是顺序栈还是链式栈,入栈/出栈只涉及栈顶个别数据的操作,所以时间复杂度都是O(1).

# 队列(Queue)

> 先进先出为队列(实例:排队买票,先来的先买)

栈只支持两个基本操作:入栈push和出栈pop,而队列与栈相似也只支持两个基本操作:入队enqueue(从队列尾部放入数据)出队dequeue(从队列头部取出一个元素)

![队列与栈](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/队列与栈.webp)

所以队列与栈一样,也是一种操作受限的线性表数据结构.

## 顺序队列和链式队列

数组实现为**顺序队列**,链表实现为**链式队列**

```java
public class ArrayQueue {
    // 数组:items,数组大小:n
    private String[] items;
    private int n = 0;
    // head表示队头下标,tail表示队尾下标
    private int head = 0;
    private int tail = 0;
    
    // 申请一个大小为capacity大小的数组
    public ArrayQueue(int capacity) {
        items = new String[capacity];
        n = capacity;
    }
    
    // 入队
    public boolean enqueue(String item) {
        if(tail == n) return false;
        items[tail] = item;
        ++tail;
        return true;
    }
    
    // 出队
    public String dequeue() {
        if (tail == head) return null;
        ++head;
        return items[tail];
    }
}
```

相对于栈只需一个**栈顶指针**.队列需要两个指针,一个head指针指向队头,一个tail指针,指向队尾.

# 排序

## 排序算法的执行效率

1. 最好情况/最坏情况/平均情况时间复杂度

   需要分析出最好/最坏时间复杂度对应的排序的原始数据是什么样的;为什么要区分三种时间复杂度?

   1. 部分排序算法需要区分,为好对比,都做区分;

   2. 对于需要排序的数据,有的接近无序,有的完全无需.有序度不同的数据,对于排序的执行时间有影响,需要知道算法再不同数据下的性能表现.

2. 时间复杂度的系数/常熟/低阶

3. 比较次数和交换(或移动)次数

   1. ==排序算法的内存消耗==;原地排序,特指空间复杂度时O(1)的排序算法
   2. ==排序算法的稳定性==;指待排序的序列中存在相等的元素,经过排序之后,相等元素之间原有的先后顺序不变

## 冒泡(Bubble Sort)

> 冒泡只会操作相邻的两个数据.==每次冒泡操作都会对相邻的两个元素进行比较,看是否满足大小关系要求.如果不满足就让它俩互换.一次冒泡会让至少一个元素移动到它应该在的位置,重复n次,就完成了n个数据的排序工作.==

![冒泡排序过程](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/冒泡排序过程.webp)

上述的冒泡排序还存在优化空间,当某次冒泡已经没有数据交换时,就已经达到完全有序的状态,不用再继续执行后续的冒泡操作.

```java
// 冒泡排序,a表示数组,n表示数组大小
public void bubbleSort(int[] a, int n) {
    if (n <= 1) return;
    
    for(int i = 0; i < n; i++) {
        // 提前退出冒泡循环的标志
		boolean flag = false;
        for(int j = 0;j < n - 1 - i; j++) {
            if(a[j] > a[j + 1]) {// 交换
                flag = true;// 表示有数据交换
                int tmp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = tmp;
            }
        }
        if (!flag) break;
    }
}
```

冒泡排序只设计响铃数据的交换操作,空间复杂度为O(1),是一个原地排序算法;在冒泡排序中,只有交换才可以改变两个元素的前后顺序,在比较时两个元素大小相等不做交换,因此是一个稳定的排序算法.时间复杂度最好情况O(n),最坏情况O($n^2$),平均也是O($n^2$).

## 插入(Insertion Sort)

> 将数组分为**已排序区间**和**未排序区间**.处室已排序区间只有一个,为数组第一个元素;==核心思想:取未排序区间中的元素,在已排序区间中找到合适的插入位置将其插入,并保证已排序区间数据一直有序.==直至未排序区间中元素为空,算法结束.

```java
public void insertionSort(int[] nums) {
    if (nums.length <= 1) return;
    
    for (int i = 1;i < nums.length;i++) {
        int value = nums[i];
        int j = i - 1;
        while (j >= 0) {
            if (a[j] > value) {
                a[j + 1] = a[j];
            } else {
                break;
            }
            j--;
        }
        a[j + 1] = value;
    }
}
```

插入排序:是原地排序算法,是稳定排序算法,最好O(n),最坏O($n^2$),平均O($n^2$).

## 选择排序(Selection Sort)

> 类似插入排序,分已排序区间和未排序区间.选择排序每次从未排序区间中找到最小的元素,将其放到已排序区间的末尾.

空间复杂度O(1),时间:最好/最坏/平均都是O($n^2$)

## 归并排序(Merge Sort)

> 先将数组从中间分成前后两个部分,然后对前后两部分分别进行排序,再将排好的两部分合并在一起

![归并排序](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/归并排序.jpg)

归并排序使用**分治**思想

```java
public void mergeSort(int[] num, int left, int right, int[] tmp) {
        if (left < right) {
            int mid = (left + right) / 2;
            mergeSort(num, left, mid, tmp);
            mergeSort(num, mid + 1, right, tmp);
            merge(num, left, mid, right, tmp);
        }
    }

    public void merge(int[] num, int left, int mid, int right, int[] tmp) {
        int i = left;
        int j = mid + 1;
        int k = 0;
		// 循环增大,比较数组内两区域的,将小的先放入临时数组,直至一个区域填完
        while (i <= mid && j <= right) {
            if (num[i] < num[j]) {
                tmp[k] = num[i];
                i++;
            } else {
                tmp[k] = num[j];
                j++;
            }
            k++;
        }

        // 将剩下的区域的剩下数组赋值进临时数组
        while (i <= mid) {
            tmp[k] = num[i];
            k++;
            i++;
        }

        while (j <= right) {
            tmp[k] = num[j];
            k++;
            j++;
        }

        k = 0;
        while (left <= right) {
            num[left++] = tmp[k++];
        }
    }
```

时间复杂度 最好/最坏/平均皆为O($nlogn$)

## 快速排序(Quick Sort)

> 如需排序数组中下标l->r之前的一组数据,选择数组中任意一个数据作为pivot(分去点),遍历l->r之间所有的数据,小于pivot放至左边,大于pivot放至右边,pivot放至之间.依次再进行左右区间的排序.

![快速排序](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/快速排序.jpg)

时间复杂度一般都是O($nlogn$),最坏情况下为O($n^2$)

## 桶排序(Bucket Sort)

> 将要排序的数据分到几个有序的桶里,每个桶里的数据单独进行排序,桶内排完,再每个桶依序取出组成.

![桶排序](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/桶排序.webp)

优点:适用于外部排序,数据量比较大的情况,内存有限,无法将数据全部加载岛内存中.(在硬盘中)

缺点:对要排序的数据要求苛刻.首先,==数据需要很容易能划分成m个桶==,且,==桶与桶之间有着天然的大小顺序==;其次==数据再各个桶之间的分布均匀==.如果分布不均匀则导致时间复杂度逐渐向O($nlogn$)靠近.

## 计数排序(Counting Sort)

> 桶排序的一种特殊情况.适用于数据量大,范围小的情况.

```java
public static void main(String[] args) {
    int[] arr = {2,4,2,5,1,5,9,6,3,2,4,3,0,3,5,6,3,2,8,3,2,2,6};
    sort(arr);
}

public static void sort(int[] arr) {
    if (num.length <= 1) return;

    // 取出数组范围
    int min = num[0];
    int max = num[0];
    for (int i = 0; i < num.length; i++) {
        int temp = num[i];
        if (temp < min) min = temp;
        if (temp > max) max = temp;
    }

    // 根据数组范围建立范围数组
    int[] arr = new int[max - min + 1];

    // 生成各数字计数数组
    for (int i = 0; i < num.length; i++) {
        int j = num[i] - min;
        arr[j] = arr[j] + 1;
    }

    // 根据计数数组排序新数组
    int index = 0;
    for (int i = 0; i < arr.length; i++) {
        while (arr[i] > 0) {
            arr[i]--;
            num[index++] = min + i;
        }
    }
}
```

# 二分查找

![二分查找](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1632379399065二分查找.webp)

```java
public int bsearch(int[] a, int value) {
    int low = 0;
    int high = a.length - 1;
    
    while (low <= high) {
        int mid = (low + high) / 2;
        if (a[mid] == value) {
            return mid;
        } else if (a[mid] < value) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return -1;
}
```

**二分查找的局限**

1. 二分查找依赖顺序表结构,需要满足下标随机访问元素.
2. 针对有序数据
3. 数据量小不适合二分查找
4. 数据量大也不适合二分查找

# 跳表

> 二分查找底层依赖的是数组的随机访问的特性,所以只能用数组来实现.如果数据存储再链表中,我们可以对链表稍加改造,使它也拥有类似于二分查找的算法功能. 那就是我们的跳表(Skip list).

我们通过给链表加索引的方式来加快查找的速度

![一级索引](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1632380636552一级索引跳表.webp)

==加了一层索引之后,查找一个节点的个数减少了.查找效率提高了,如果我们多加几级索引之后呢==

![二级索引跳表](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1632380744879二级索引跳表.webp)

![1632380850336跳表查找.webp (1142×636) (raw.githubusercontent.com)](https://raw.githubusercontent.com/siTsang546/img-repo/main/data_struct/1632380850336跳表查找.webp)

# 散列表(Hash Table)

## 散列思想

==散列表使用数组下标随机访问时间复杂度为O(1)得特性.通过散列函数把元素的键值映射为下标,然后将数据存储再数组对应下标得位置.当我们按照键值查询元素时,使用同样得散列函数,将键值转化为数组下标,从对应得数组下标位置取得相应得数据.==

![](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1632640518160散列表.jpg)

## 散列函数

从上述例子中可以看出散列函数是非常重要的.

散列函数可以定义成**hash(key)**,其中key表示元素的键值,hash(key)的值表经散列函数计算得到的散列值.

散列函数设计的基本要求:

1. 散列函数计算得到的散列值是一个非负整数;
2. if key1 = key2, then hash(key1) == hash(key2)
3. if key1 != key2, then hash(key1) != hash(key2)

第三点,要想找到一个不同的key对应的散列值都不一样的散列函数,几乎不可能.**散列冲突**无法避免.且有限的数组会加大散列冲突的概率.

因此我们需要通过另外的途径来解决散列冲突的问题.

## 散列冲突

> 通常使用开放寻址发(open addressing)和链表发(chaining).

### 开放寻址法

核心思想:==如果出现了散列冲突,重新探测一个空闲位置,将其插入.==

**线性探测**(Linear Probing)

当我们往散列表中插入数据时,如果某个数据经过散列函数散列之后,存储位置已经被占用了,我们就从当前位置开始,依次往后查找,看是否有空闲位置,知道找到为止.

![开放寻址法,黄色为空闲位,橙色为有值位.](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1632643482664开放寻址法.jpg)

==黄色为空闲位,橙色为有值位.==

==查找==:根据散列函数得出的下标去寻找相应的键值,如果不对应,就继续往下查找,直到查至下一个空闲位置则停止.

![开放寻址法查找](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1632643680722开放寻址法查找.jpg)

==删除==:删除时不可将元素设置为空,因为后续查找的时候查询到此处判断为空则会直接结束,导致原有的查找算法失效.,可以==将删除的元素特殊标记为deleted.当线性探测查找的时候,遇到标记为deleted的空间,并不是停下,二十继续往下探测.==

![](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1632645151546开放寻址法删除.jpg)

除开线性探测外,还有另外两种经典的方式**二次探测(Quadratic probing)**和**双重散列(Double hashing)**

==二次探测==:与线性探测很像,线性谈下步长为1,下标序列就是hash(key)+0,hash(key)+1,hash(key)+2...而二次探测探测的步长变成了原来的二次方,下标序列为hash(key)+0,hash(key)+$1^2$,hash(key)+$2^2$...

==双重散列==:意为补仅使用一个散列函数.使用一组散列函数hash1(key),hash2(key),hash3(key)...我们先用第一个散列函数,如果计算得到的存储位置已经被占用,在用第二个散列函数,以此类推,知道找到空闲的存储位置.

但不管采用哪种探测方式,当散列表空闲位置不多时,散列冲突概率会大大提高.为尽可能保证散列表操作效率,一般情况下,我们会尽可能保证散列表中有一定比例空闲位置.我们用**装载因子(load factor)**来表示空位的多少.

装在因子公式:`散列表的装载因子=填入表中的元素个数/散列表的长度`

### 链表法

![](https://cdn.jsdelivr.net/gh/siTsang546/img-repo@main/data_struct/1632646152642链表法.jpg)

